> Casa认为的致命错误二：组件化的中间件为openUrl提供服务，而不是openUrl方式为组件化提供服务。
> Casa给出的解释：也就是说，一个App的组件化方案一定不是建立在URL上的，openURL的跨App调用是可以建立在组件化方案上的。当然，如果App还没有组件化，openURL方式也是可以建立的，就是丑陋一点而已。
> 我自己的理解：中间件可以提供各式各样的服务，其中包括提供以 `openUrl` 的方式调用接口， `openUrl` 只是一种方式，而不是所谓的为XXX提供服务。

关于组件化方案中的去model设计的理解：

模块间传递参数，如果细颗粒度，以股票软件为例：赋值stockcode,stockName,marketId等等，细致到每一个参数；而如果从粗颗粒度来说，可以是传递一个封装好的stockInfo model进去，它包含了股票代码 股票名称 市场；再比如规范某个模块的传递参数接口 —— Protocol，可以是方法（updatestockcode:stockname:xxx），也可以是直接赋值一个遵循某个协议的属性（`self.stockInfo = id<StockInfoProtocl>`）。

传参必定是一个对象！

如果传一个具体的对象，必定要绑定对象的类，即使用协议，至少也要依赖一个协议。

对于为何不用面向接口的对象，目前不是很清楚，主要原因可能与模块依赖关系有关。

使用字典传递参数自由度很大，但如何保证响应方正确理解传递过来的参数又是一大问题。

> 使用Category进行业务划分 和所谓的组件化 是本文对我最大的收获

首先 mediator 作为中间这，基类是提供服务方，而且仅提供服务，而在其基础上进行扩展的内容是业务，比如规定可以调用什么接口，参数的key值等等。

本文对 Target-Action的 runtime 调用没有太多涉及，打算在下一篇直接阅读源代码。本文其他就没有亮点了，至于参数传递解析到时候源代码阅读时候一并看了。


蘑菇街关于对非常规参数的传递，用 `modulManager` ，提供一个 `registerClass:forProtocol` 方法，并未完全理解，但是给我提供了一些思路。

